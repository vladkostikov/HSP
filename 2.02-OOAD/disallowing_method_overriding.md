# Запрет переопределения методов в потомках

## Ruby

В Ruby отсутствует встроенный механизм для запрета переопределения методов в потомках.

Все классы в Ruby являются открытыми.
У разработчика есть полная свобода действий, в том числе возможность изменять любые классы, библиотеки и даже ядро языка.

Допускаются добавление, изменение и удаление существующих методов в любой момент работы программы.
Подразумевается, что разработчик знает, что делает и несёт ответственность за свои действия.

Существуют способы частично ограничить переопределение методов, но их можно обойти.
Такие решения фактически нигде не используются.

## Java

В Java ключевое слово final запрещает переопределение методов в потомках.

Пример:
```java
class Cat {
    // Метод speak помечен как final, чтобы запретить переопределение.
    public final String speak() {
        return "meow";
    }
}

class Lion extends Cat {
    // Попытка переопределить метод speak вызовет ошибку компиляции "error: speak() in Lion cannot override speak() in Cat".
    /*
    @Override
    public String speak() {
        return "roar";
    }
    */
}

public class Main {
    public static void main(String[] args) {
        Cat cat = new Cat();
        Lion lion = new Lion();

        System.out.println("Cat says: " + cat.speak()); // Вывод: Cat says: meow
        System.out.println("Lion says: " + lion.speak()); // Вывод: Lion says: meow
    }
}
```
